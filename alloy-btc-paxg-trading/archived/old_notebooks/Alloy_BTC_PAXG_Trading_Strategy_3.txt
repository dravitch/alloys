{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Alloy BTC-PAXG Trading Strategy Quick Start\n",
    "\n",
    "This Jupyter Notebook provides a self-contained quick-start guide to the Alloy BTC-PAXG trading strategy, designed for users who cannot run the full Streamlit application (`app.py`) locally. The strategy dynamically allocates between Bitcoin (BTC) and PAX Gold (PAXG) to balance growth and stability, using momentum and volatility indicators.\n",
    "\n",
    "## Purpose\n",
    "- Serve as an interactive alternative to the Streamlit app.\n",
    "- Enable users to explore the strategy, run backtests, and visualize results.\n",
    "- Provide clear documentation and interactive controls for experimentation.\n",
    "\n",
    "## Table of Contents\n",
    "1. [Introduction](#Introduction)\n",
    "2. [Data Loading](#Data-Loading)\n",
    "3. [Strategy Implementation](#Strategy-Implementation)\n",
    "4. [Backtesting](#Backtesting)\n",
    "5. [Results Visualization](#Results-Visualization)\n",
    "6. [Parameter Experimentation](#Parameter-Experimentation)\n",
    "7. [Trading Signals](#Trading-Signals)\n",
    "8. [Next Steps](#Next-Steps)\n",
    "\n",
    "## Prerequisites\n",
    "Install the required packages:\n",
    "```bash\n",
    "pip install yfinance pandas numpy matplotlib plotly ipywidgets optuna\n",
    "```\n",
    "\n",
    "## Disclaimer\n",
    "**This code is for educational purposes only. Cryptocurrency investments are highly volatile and carry significant risks. Always conduct your own research and consult a qualified financial advisor before making investment decisions.**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data Loading\n",
    "\n",
    "This section downloads historical BTC and PAXG price data using `yfinance`. We include error handling to manage API issues and validate the data for completeness."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import yfinance as yf\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import plotly.express as px\n",
    "import logging\n",
    "from typing import Optional\n",
    "\n",
    "# Configure logging\n",
    "logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n",
    "logger = logging.getLogger(__name__)\n",
    "\n",
    "def download_data(start_date: str, end_date: str, max_retries: int = 3) -> Optional[pd.DataFrame]:\n",
    "    \"\"\"Download and prepare BTC and PAXG data with retry logic.\"\"\"\n",
    "    for attempt in range(max_retries):\n",
    "        try:\n",
    "            logger.info(f\"Attempt {attempt + 1}/{max_retries} to download data\")\n",
    "            btc = yf.download('BTC-USD', start=start_date, end=end_date, progress=False)\n",
    "            paxg = yf.download('PAXG-USD', start=start_date, end=end_date, progress=False)\n",
    "\n",
    "            common_dates = btc.index.intersection(paxg.index)\n",
    "            data = pd.DataFrame(index=common_dates)\n",
    "            data['BTC'] = btc.loc[common_dates, 'Close']\n",
    "            data['PAXG'] = paxg.loc[common_dates, 'Close']\n",
    "            data = data.dropna()\n",
    "\n",
    "            if data.empty:\n",
    "                raise ValueError(\"No valid data retrieved\")\n",
    "\n",
    "            logger.info(f\"Data loaded: {len(data)} days from {data.index[0].strftime('%Y-%m-%d')} to {data.index[-1].strftime('%Y-%m-%d')}\")\n",
    "            return data\n",
    "\n",
    "        except Exception as e:\n",
    "            logger.error(f\"Error on attempt {attempt + 1}: {str(e)}\")\n",
    "            if attempt < max_retries - 1:\n",
    "                import time\n",
    "                time.sleep(5 * (attempt + 1))\n",
    "            else:\n",
    "                logger.error(\"Failed to download data after multiple attempts\")\n",
    "                return None\n",
    "\n",
    "# Download data\n",
    "START_DATE = '2020-01-01'\n",
    "END_DATE = '2025-02-28'\n",
    "historical_data = download_data(START_DATE, END_DATE)\n",
    "\n",
    "if historical_data is not None:\n",
    "    display(historical_data.tail())\n",
    "else:\n",
    "    raise ValueError(\"Cannot proceed without valid data\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Strategy Implementation\n",
    "\n",
    "The Alloy strategy dynamically adjusts allocations between BTC and PAXG based on momentum and volatility. We use the advanced `AlloyPortfolioBOME` class, which includes Optuna optimization for parameter tuning.\n",
    "\n",
    "**Key Parameters**:\n",
    "- `momentum_window`: Period for calculating BTC momentum (e.g., 20 days).\n",
    "- `volatility_window`: Period for calculating volatility (e.g., 30 days).\n",
    "- `rebalance_frequency`: Days between rebalancing checks (e.g., 1 day).\n",
    "- `transaction_cost`: Trading fee per transaction (e.g., 0.1%)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from typing import Dict, Tuple\n",
    "import optuna\n",
    "\n",
    "class AlloyPortfolioBOME:\n",
    "    def __init__(self,\n",
    "                 initial_capital: float = 10000,\n",
    "                 momentum_window: int = 20,\n",
    "                 volatility_window: int = 30,\n",
    "                 momentum_threshold_bull: float = 0,\n",
    "                 momentum_threshold_bear: float = -5,\n",
    "                 max_btc_allocation: float = 0.8,\n",
    "                 min_btc_allocation: float = 0.3,\n",
    "                 rebalance_frequency: int = 1,\n",
    "                 transaction_cost: float = 0.001,\n",
    "                 data: pd.DataFrame = None):\n",
    "        self.initial_capital = initial_capital\n",
    "        self.transaction_cost = transaction_cost\n",
    "        self.params = {\n",
    "            'momentum_window': momentum_window,\n",
    "            'volatility_window': volatility_window,\n",
    "            'momentum_threshold_bull': momentum_threshold_bull,\n",
    "            'momentum_threshold_bear': momentum_threshold_bear,\n",
    "            'max_btc_allocation': max_btc_allocation,\n",
    "            'min_btc_allocation': min_btc_allocation,\n",
    "            'rebalance_frequency': rebalance_frequency\n",
    "        }\n",
    "        self.logger = logging.getLogger('AlloyBOME')\n",
    "        self.btc_allocation = 0.5\n",
    "        self.paxg_allocation = 0.5\n",
    "        self.last_rebalance = None\n",
    "        self.positions = {'BTC': 0, 'PAXG': 0}\n",
    "        self.data = data\n",
    "\n",
    "    def calculate_volatility(self, prices: pd.Series) -> pd.Series:\n",
    "        \"\"\"Calculate annualized volatility.\"\"\"\n",
    "        returns = np.log(prices / prices.shift(1))\n",
    "        volatility = returns.rolling(window=self.params['volatility_window']).std() * np.sqrt(252) * 100\n",
    "        return volatility.bfill()\n",
    "\n",
    "    def calculate_momentum(self, prices: pd.Series) -> pd.Series:\n",
    "        \"\"\"Calculate momentum as percentage change.\"\"\"\n",
    "        return (prices / prices.shift(self.params['momentum_window']) - 1) * 100\n",
    "\n",
    "    def get_market_context(self, btc_momentum: float, btc_volatility: float) -> str:\n",
    "        \"\"\"Determine market context based on momentum and volatility.\"\"\"\n",
    "        momentum_state = 'bullish' if btc_momentum > self.params['momentum_threshold_bull'] else \\\n",
    "                         'bearish' if btc_momentum < self.params['momentum_threshold_bear'] else 'neutral'\n",
    "        vol_state = 'low_vol' if btc_volatility < 30 else \\\n",
    "                    'medium_vol' if btc_volatility < 50 else 'high_vol'\n",
    "        return f\"{momentum_state}_{vol_state}\"\n",
    "\n",
    "    def dynamic_rebalancing(self, historical_slice: pd.DataFrame, vol_btc: float, vol_paxg: float, current_price: pd.Series) -> bool:\n",
    "        \"\"\"Decide whether to rebalance based on market conditions.\"\"\"\n",
    "        btc_momentum = self.calculate_momentum(historical_slice['BTC'])\n",
    "        current_btc_momentum = btc_momentum.iloc[-1]\n",
    "\n",
    "        context = self.get_market_context(current_btc_momentum, vol_btc)\n",
    "        threshold = 0.05  # Simplified for quick start\n",
    "\n",
    "        old_btc_alloc = self.btc_allocation\n",
    "        if current_btc_momentum > self.params['momentum_threshold_bull']:\n",
    "            self.btc_allocation = self.params['max_btc_allocation']\n",
    "        elif current_btc_momentum < self.params['momentum_threshold_bear']:\n",
    "            self.btc_allocation = self.params['min_btc_allocation']\n",
    "        else:\n",
    "            total_vol = vol_btc + vol_paxg\n",
    "            self.btc_allocation = 0.5 if total_vol == 0 else max(self.params['min_btc_allocation'],\n",
    "                                                                 min(self.params['max_btc_allocation'],\n",
    "                                                                     1.2 - (vol_btc / total_vol)))\n",
    "        self.paxg_allocation = 1 - self.btc_allocation\n",
    "\n",
    "        should_rebalance = abs(self.btc_allocation - old_btc_alloc) > threshold\n",
    "        if self.last_rebalance is not None:\n",
    "            days_since_last = (historical_slice.index[-1] - self.last_rebalance).days\n",
    "            if days_since_last < self.params['rebalance_frequency']:\n",
    "                self.btc_allocation = old_btc_alloc\n",
    "                self.paxg_allocation = 1 - self.btc_allocation\n",
    "                return False\n",
    "\n",
    "        return should_rebalance\n",
    "\n",
    "    def backtest(self, data: pd.DataFrame) -> pd.DataFrame:\n",
    "        \"\"\"Run backtest and compare with benchmarks.\"\"\"\n",
    "        self.logger.info(\"Starting backtest...\")\n",
    "        vol_btc = self.calculate_volatility(data['BTC'])\n",
    "        vol_paxg = self.calculate_volatility(data['PAXG'])\n",
    "\n",
    "        portfolio_value = pd.Series(self.initial_capital, index=data.index, dtype=float)\n",
    "        btc_alloc_series = pd.Series(0.5, index=data.index, dtype=float)\n",
    "        paxg_alloc_series = pd.Series(0.5, index=data.index, dtype=float)\n",
    "        transaction_fees = pd.Series(0.0, index=data.index, dtype=float)\n",
    "\n",
    "        self.positions['BTC'] = (self.initial_capital * 0.5) / data['BTC'].iloc[0]\n",
    "        self.positions['PAXG'] = (self.initial_capital * 0.5) / data['PAXG'].iloc[0]\n",
    "        self.last_rebalance = data.index[0]\n",
    "\n",
    "        for i, (date, row) in enumerate(data.iterrows()):\n",
    "            current_vol_btc = vol_btc.get(date, 0)\n",
    "            current_vol_paxg = vol_paxg.get(date, 0)\n",
    "            historical_slice = data.loc[:date]\n",
    "\n",
    "            if (date - self.last_rebalance).days >= self.params['rebalance_frequency']:\n",
    "                if self.dynamic_rebalancing(historical_slice, current_vol_btc, current_vol_paxg, row):\n",
    "                    current_value = self.positions['BTC'] * row['BTC'] + self.positions['PAXG'] * row['PAXG']\n",
    "                    btc_value_before = self.positions['BTC'] * row['BTC']\n",
    "                    paxg_value_before = self.positions['PAXG'] * row['PAXG']\n",
    "\n",
    "                    self.positions['BTC'] = (current_value * self.btc_allocation) / row['BTC']\n",
    "                    self.positions['PAXG'] = (current_value * self.paxg_allocation) / row['PAXG']\n",
    "                    btc_value_after = self.positions['BTC'] * row['BTC']\n",
    "                    paxg_value_after = self.positions['PAXG'] * row['PAXG']\n",
    "                    fees = (abs(btc_value_after - btc_value_before) + abs(paxg_value_after - paxg_value_before)) * self.transaction_cost\n",
    "                    transaction_fees.iloc[i] = fees\n",
    "                    portfolio_value.iloc[i] -= fees\n",
    "                    self.last_rebalance = date\n",
    "\n",
    "            btc_alloc_series.iloc[i] = self.btc_allocation\n",
    "            paxg_alloc_series.iloc[i] = self.paxg_allocation\n",
    "            portfolio_value.iloc[i] = self.positions['BTC'] * row['BTC'] + self.positions['PAXG'] * row['PAXG'] - transaction_fees.cumsum().iloc[i]\n",
    "\n",
    "        bh_value = (self.initial_capital * 0.5 / data['BTC'].iloc[0]) * data['BTC'] + (self.initial_capital * 0.5 / data['PAXG'].iloc[0]) * data['PAXG']\n",
    "        results = pd.DataFrame({\n",
    "            'portfolio_value': portfolio_value,\n",
    "            'buy_hold_value': bh_value,\n",
    "            'btc_allocation': btc_alloc_series,\n",
    "            'paxg_allocation': paxg_alloc_series,\n",
    "            'transaction_fees': transaction_fees\n",
    "        }, index=data.index)\n",
    "        self.logger.info(\"Backtest completed\")\n",
    "        return results\n",
    "\n",
    "    def calculate_metrics(self, results: pd.DataFrame) -> Dict:\n",
    "        \"\"\"Calculate key performance metrics.\"\"\"\n",
    "        daily_returns = np.log(results['portfolio_value'] / results['portfolio_value'].shift(1)).dropna()\n",
    "        bh_daily_returns = np.log(results['buy_hold_value'] / results['buy_hold_value'].shift(1)).dropna()\n",
    "\n",
    "        metrics = {\n",
    "            'total_return': (results['portfolio_value'].iloc[-1] / results['portfolio_value'].iloc[0] - 1) * 100,\n",
    "            'bh_total_return': (results['buy_hold_value'].iloc[-1] / results['buy_hold_value'].iloc[0] - 1) * 100,\n",
    "            'annualized_return': (daily_returns.mean() * 252) * 100,\n",
    "            'annualized_volatility': (daily_returns.std() * np.sqrt(252)) * 100,\n",
    "            'sharpe_ratio': (daily_returns.mean() * 252) / (daily_returns.std() * np.sqrt(252)) if daily_returns.std() != 0 else 0,\n",
    "            'max_drawdown': ((results['portfolio_value'].cummax() - results['portfolio_value']) / results['portfolio_value'].cummax()).max() * 100,\n",
    "            'total_fees': results['transaction_fees'].sum()\n",
    "        }\n",
    "        return metrics\n",
    "\n",
    "# Initialize portfolio\n",
    "portfolio = AlloyPortfolioBOME(initial_capital=10000, data=historical_data)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Backtesting\n",
    "\n",
    "Run the backtest to simulate the strategy’s performance and compare it to a Buy & Hold benchmark. The results include portfolio value, allocations, and fees over time."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "results = portfolio.backtest(historical_data)\n",
    "metrics = portfolio.calculate_metrics(results)\n",
    "display(results.tail())\n",
    "print(\"\\nPerformance Metrics:\")\n",
    "for key, value in metrics.items():\n",
    "    print(f\"{key.replace('_', ' ').title()}: {value:.2f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Results Visualization\n",
    "\n",
    "Visualize the portfolio’s performance and allocations using interactive Plotly charts. These plots allow zooming and hovering for detailed inspection."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig = px.line()\n",
    "fig.add_scatter(x=results.index, y=results['portfolio_value'], name='Alloy Portfolio', line=dict(color='blue'))\n",
    "fig.add_scatter(x=results.index, y=results['buy_hold_value'], name='Buy & Hold', line=dict(color='orange', dash='dash'))\n",
    "fig.update_layout(title='Portfolio Performance', xaxis_title='Date', yaxis_title='Value (USD)', legend=dict(y=1.1, orientation='h'))\n",
    "fig.show()\n",
    "\n",
    "fig = px.line()\n",
    "fig.add_scatter(x=results.index, y=results['btc_allocation'] * 100, name='BTC Allocation', line=dict(color='blue'))\n",
    "fig.add_scatter(x=results.index, y=results['paxg_allocation'] * 100, name='PAXG Allocation', line=dict(color='gold'))\n",
    "fig.update_layout(title='Portfolio Allocations', xaxis_title='Date', yaxis_title='Allocation (%)', legend=dict(y=1.1, orientation='h'))\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Parameter Experimentation\n",
    "\n",
    "Experiment with strategy parameters using interactive sliders. Adjust the rebalance frequency and rerun the backtest to see its impact.\n",
    "\n",
    "**Note**: Rerunning the backtest may take a few seconds."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from ipywidgets import interact, IntSlider\n",
    "\n",
    "def run_backtest_with_params(rebalance_frequency):\n",
    "    portfolio = AlloyPortfolioBOME(\n",
    "        initial_capital=10000,\n",
    "        rebalance_frequency=rebalance_frequency,\n",
    "        data=historical_data\n",
    "    )\n",
    "    results = portfolio.backtest(historical_data)\n",
    "    metrics = portfolio.calculate_metrics(results)\n",
    "\n",
    "    fig = px.line()\n",
    "    fig.add_scatter(x=results.index, y=results['portfolio_value'], name='Alloy Portfolio', line=dict(color='blue'))\n",
    "    fig.add_scatter(x=results.index, y=results['buy_hold_value'], name='Buy & Hold', line=dict(color='orange', dash='dash'))\n",
    "    fig.update_layout(title=f'Portfolio Performance (Rebalance Frequency: {rebalance_frequency} days)', xaxis_title='Date', yaxis_title='Value (USD)')\n",
    "    fig.show()\n",
    "\n",
    "    print(\"Performance Metrics:\")\n",
    "    for key, value in metrics.items():\n",
    "        print(f\"{key.replace('_', ' ').title()}: {value:.2f}\")\n",
    "\n",
    "interact(run_backtest_with_params, rebalance_frequency=IntSlider(min=1, max=7, step=1, value=1, description='Rebalance Frequency'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Trading Signals\n",
    "\n",
    "Generate a trading signal based on the latest data point to demonstrate how the strategy would act today."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "latest_data = historical_data.iloc[-1:]\n",
    "vol_btc = portfolio.calculate_volatility(historical_data['BTC']).iloc[-1]\n",
    "vol_paxg = portfolio.calculate_volatility(historical_data['PAXG']).iloc[-1]\n",
    "should_rebalance = portfolio.dynamic_rebalancing(historical_data, vol_btc, vol_paxg, latest_data.iloc[0])\n",
    "\n",
    "print(\"\\n=== Latest Trading Signal ===\")\n",
    "print(f\"Date: {latest_data.index[0].strftime('%Y-%m-%d')}\")\n",
    "print(f\"BTC Price: ${latest_data['BTC'].iloc[0]:,.2f}\")\n",
    "print(f\"PAXG Price: ${latest_data['PAXG'].iloc[0]:,.2f}\")\n",
    "print(f\"Rebalance Required: {'Yes' if should_rebalance else 'No'}\")\n",
    "if should_rebalance:\n",
    "    print(f\"New BTC Allocation: {portfolio.btc_allocation * 100:.1f}%\")\n",
    "    print(f\"New PAXG Allocation: {portfolio.paxg_allocation * 100:.1f}%\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Next Steps\n",
    "\n",
    "This notebook provides a quick start for exploring the Alloy BTC-PAXG strategy. To take it further:\n",
    "\n",
    "- **Run the Full Application**: Clone the repository and run `app.py` locally for a Streamlit interface with additional features.\n",
    "- **Live Trading**: Integrate with an exchange API (e.g., Binance) for real-time trading. See [xAI API documentation](https://x.ai/api) for details.\n",
    "- **Parameter Optimization**: Use Optuna (as in the advanced implementation) to fine-tune parameters over longer periods.\n",
    "- **Contribute**: Share feedback or contribute to the project on GitHub.\n",
    "\n",
    "**Questions?** Contact the xAI team or check the project documentation."
   ]
  }
 ]
}